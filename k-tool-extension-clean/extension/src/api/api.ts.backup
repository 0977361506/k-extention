import mermaid from 'mermaid';
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkRehype from 'remark-rehype';
import rehypeStringify from 'rehype-stringify';
import { visit } from 'unist-util-visit';
import type { Root } from 'hast';
import escapeHtml from 'escape-html';
// Import DOMPurify and HTML processing libraries
import DOMPurify from 'dompurify';
import * as htmlparser2 from 'htmlparser2';
import * as he from 'he';
import { DiagramData, getDiagramConfluenceStyles } from '../utils/mermaidExporter';

// Initialize mermaid globally
mermaid.initialize({
  startOnLoad: false,
  theme: 'default',
  securityLevel: 'loose',
  fontFamily: '"Segoe UI", "Arial Unicode MS", "Lucida Grande", Roboto, "Noto Sans", "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"'
});

export function initializeMermaid() {
  mermaid.initialize({
    startOnLoad: false,
    theme: 'default',
    securityLevel: 'loose',
    fontFamily: '"Segoe UI", "Arial Unicode MS", "Lucida Grande", Roboto, "Noto Sans", "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji"',
    flowchart: {
      useMaxWidth: true,
      htmlLabels: true
    },
    themeVariables: {
      fontFamily: '"Segoe UI", "Arial Unicode MS", "Lucida Grande", Roboto, "Noto Sans", "Helvetica Neue", Arial, sans-serif'
    }
  });
}

// ================================================================================= 
// TEMPLATE CLONING INTERFACES
// =================================================================================
export interface ClonedTemplate {
  title: string;
  originalStorageFormat: string;
  templateStructure: string;
  analysisInfo: {
    emptyParagraphs: number;
    emptyTableCells: number;
    totalLength: number;
  };
}

export interface GeneratedDocument {
  title: string;
  fullStorageFormat: string;
  generatedAt: string;
}

// ================================================================================= 
// ENHANCED XML VALIDATION - SIMPLIFIED VERSION
// =================================================================================

/**
 * DEPRECATED - Use convertToMermaidCloudMacros instead
 * Fix invalid prefixes and content structure - CRITICAL FIX
 */
/*
function fixContentPrefixAndStructure(content: string): string {
  // This function is deprecated and replaced by convertToMermaidCloudMacros
  return content;
}
*/

/**
 * DEPRECATED - Use basicContentCleanup instead
 * Comprehensive XML validation and sanitization
 */
/*
function validateAndSanitizeXML(storageFormat: string): string {
  // This function is deprecated and replaced by simpler approach
  return basicContentCleanup(storageFormat);
}
*/

/**
 * DEPRECATED - All complex validation functions have been simplified
 * Fix XML attributes comprehensively
 */
/*
function fixXmlAttributes(content: string): string {
  // This function is deprecated
  return content;
}
*/

/**
 * DEPRECATED
 * Fix CDATA sections and escape sequences
 */
/*
function fixCdataAndEscapeSequences(content: string): string {
  // This function is deprecated
  return content;
}
*/

/**
 * DEPRECATED
 * Ensure Confluence namespaces
 */
/*
function ensureConfluenceNamespaces(content: string): string {
  // This function is deprecated
  return content;
}
*/

/**
 * DEPRECATED
 * Fix table structure
 */
/*
function fixTableStructure(content: string): string {
  // This function is deprecated
  return content;
}
*/

/**
 * DEPRECATED
 * Fix mermaid macros with proper validation
 */
/*
function fixMermaidMacros(content: string): string {
  // This function is deprecated - replaced by convertToMermaidCloudMacros
  return content;
}
*/

/**
 * DEPRECATED
 * Fix paragraph structure
 */
/*
function fixParagraphStructure(content: string): string {
  // This function is deprecated
  return content;
}
*/

/**
 * DEPRECATED
 * Fix unmatched tags
 */
/*
function fixUnmatchedTags(xml: string): string {
  // This function is deprecated
  return xml;
}

function getTagName(tag: string): string | null {
  // This function is deprecated
  return null;
}
*/

/**
 * DEPRECATED
 * Final cleanup
 */
/*
function performFinalCleanup(content: string): string {
  // This function is deprecated
  return content;
}
*/

/**
 * DEPRECATED
 * Final validation with enhanced macro checking
 */
/*
function performFinalValidation(content: string): {
  isValid: boolean;
  warnings: string[];
  sanitized: string;
} {
  // This function is deprecated
  return {
    isValid: true,
    warnings: [],
    sanitized: content
  };
}
*/

/**
 * DEPRECATED
 * Emergency macro fix for macro name issues
 */
/*
function emergencyMacroFix(content: string): string {
  // This function is deprecated
  return content;
}
*/

/**
 * DEPRECATED
 * Emergency fallback sanitization
 */
/*
function emergencyFallbackSanitization(content: string): string {
  // This function is deprecated
  return basicContentCleanup(content);
}
*/

/**
 * SIMPLIFIED DEBUG FUNCTION - No complex validation
 */
export function debugXMLValidation(xml: string): { 
  isValid: boolean; 
  sanitized: string; 
  errors: string[]; 
  warnings: string[] 
} {
  console.log('üî¨ DEBUG: Basic XML validation...');
  
  const errors: string[] = [];
  const warnings: string[] = [];
  
  try {
    if (!xml || xml.trim().length === 0) {
      errors.push('Content is empty');
      return { isValid: false, sanitized: '', errors, warnings };
    }
    
    // Basic cleanup and macro conversion
    let sanitized = basicContentCleanup(xml);
    sanitized = convertToMermaidCloudMacros(sanitized);
    
    // Simple validation - just check if it's not empty
    const isValid = sanitized.trim().length > 0;
    
    if (!isValid) {
      errors.push('Content became empty after processing');
    } else {
      warnings.push('Content processed successfully with mermaid-cloud macros');
    }
    
    const result = {
      isValid,
      sanitized,
      errors,
      warnings
    };
    
    console.log('üî¨ DEBUG Results:', {
      isValid: result.isValid,
      errorCount: errors.length,
      warningCount: warnings.length,
      contentLength: sanitized.length
    });
    
    return result;
    
  } catch (error) {
    errors.push(`Validation exception: ${error}`);
    return {
      isValid: false,
      sanitized: basicContentCleanup(xml),
      errors,
      warnings
    };
  }
}

// ================================================================================= 
// UTILITY FUNCTIONS
// =================================================================================

/**
 * Extract page ID from Confluence URL
 */
export function extractPageIdFromUrl(url: string): string | null {
  try {
    if (!url || !url.trim()) {
      return null;
    }
    const urlObj = new URL(url);
    const pageId = urlObj.searchParams.get('pageId');
    return pageId;
  } catch (error) {
    console.error('‚ùå Error parsing URL:', error);
    return null;
  }
}

// ================================================================================= 
// MACRO CONVERSION FUNCTION
// =================================================================================

// ================================================================================= 
// DIAGRAM EXTRACTION AND CONVERSION
// =================================================================================




/**
 * Extract diagram content from macros before conversion
 */
function extractDiagramContent(macroMatch: string, filename: string, macroId: string): DiagramData {
  console.log(`üîç Extracting diagram content for: ${filename}`);
  
  let diagramCode = '';
  
  // Extract mermaid code from mermaid macro
  const mermaidCodeMatch = macroMatch.match(/<ac:parameter[^>]*ac:name="code"[^>]*>([\s\S]*?)<\/ac:parameter>/);
  if (mermaidCodeMatch) {
    diagramCode = mermaidCodeMatch[1].trim();
    
    // If wrapped in CDATA, extract content
    const cdataMatch = diagramCode.match(/<!\[CDATA\[([\s\S]*?)\]\]>/);
    if (cdataMatch) {
      diagramCode = cdataMatch[1];
    }
  }
  console.log(`‚úÖ Extracted diagram code (${diagramCode.length} chars) for: ${filename}`);
  
  return {
    filename,
    macroId,
    diagramCode
  };
}

/**
 * Convert diagram code to SVG and PNG using mermaid
 */
async function convertDiagramToSvgPng(diagram: DiagramData): Promise<DiagramData> {
  try {
    console.log(`üé® Converting diagram to SVG/PNG: ${diagram.filename}`);
    console.log(`üé® Converting diagram to SVG/PNG: ${diagram.diagramCode}`);

    // Use mermaid to render SVG
    const svgResult = await mermaid.render(`diagram-${diagram.macroId}`, diagram.diagramCode);
    
    // Handle different return types from mermaid.render
    let svgContent: string;
    if (typeof svgResult === 'string') {
      svgContent = svgResult;
    } else if (svgResult && typeof svgResult === 'object' && 'svg' in svgResult) {
      svgContent = (svgResult as any).svg;
    } else {
      throw new Error('Invalid SVG result from mermaid.render');
    }
    
    diagram.svg = svgContent;
    
    // Convert SVG to PNG using canvas
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    await new Promise((resolve, reject) => {
      img.onload = () => {
        canvas.width = img.width || 800;
        canvas.height = img.height || 600;
        
        if (ctx) {
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
          diagram.png = canvas.toDataURL('image/png').split(',')[1]; // Remove data:image/png;base64,
        }
        resolve(true);
      };
      
      img.onerror = reject;
      img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgContent)));
    });
    
    console.log(`‚úÖ Successfully converted ${diagram.filename} to SVG/PNG`);
    return diagram;
    
  } catch (error) {
    console.error(`‚ùå Failed to convert diagram ${diagram.filename}:`, error);
    
    // Create fallback PNG data
    diagram.png = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
    return diagram;
  }
}

/**
 * Convert all macros to mermaid-cloud macros with sequential naming and extract diagrams
 */
function convertToMermaidCloudMacros(content: string): string {
  console.log('üîÑ Converting all macros to mermaid-cloud macros...');
  let macroCounter = 1;
  let macroId = 111;
  
  // Replace all structured macros (mermaid, code, etc.) with mermaid-cloud macros
  const convertedContent = content.replace(
    /<ac:structured-macro[^>]*>[\s\S]*?<\/ac:structured-macro>/g,
    (match) => {
      const filename = `k-tool-diagram-${macroCounter}`;
      const currentId = macroId.toString();    
      macroCounter++;
      macroId++;
      
      console.log(`üîß Converting macro ${macroCounter - 1} to mermaid-cloud: ${filename}`);
      
      return `<ac:structured-macro ac:name="mermaid-cloud" ac:schema-version="1" ac:macro-id="${currentId}">
<ac:parameter ac:name="toolbar">bottom</ac:parameter>
<ac:parameter ac:name="filename">${filename}</ac:parameter>
<ac:parameter ac:name="format">svg</ac:parameter>
<ac:parameter ac:name="zoom">fit</ac:parameter>
<ac:parameter ac:name="revision">1</ac:parameter>
</ac:structured-macro>`;
    }
  );
  
  console.log(`‚úÖ Converted ${macroCounter - 1} macros to mermaid-cloud`);  
  return convertedContent;
}

/**
 * Additional XHTML validation specifically for TinyMCE content
 */
function validateXHTMLForConfluence(content: string): string {
  console.log('üîç Performing additional XHTML validation for Confluence...');
  
  return content
    // Fix TinyMCE specific issues
    .replace(/<p><br><\/p>/gi, '<p>&nbsp;</p>') // Replace empty paragraphs with br
    .replace(/<p><br\/><\/p>/gi, '<p>&nbsp;</p>') // Replace empty paragraphs with br/
    .replace(/<p>\s*<\/p>/gi, '<p>&nbsp;</p>') // Replace completely empty paragraphs
    
    // Fix nested paragraph issues (TinyMCE sometimes creates these)
    .replace(/<p>(<p>.*?<\/p>)<\/p>/gi, '$1') // Remove nested paragraphs
    
    // Fix table cell issues that can cause XHTML errors
    .replace(/<td><\/td>/gi, '<td>&nbsp;</td>') // Empty table cells
    .replace(/<th><\/th>/gi, '<th>&nbsp;</th>') // Empty table headers
    
    // Fix list item issues
    .replace(/<li><\/li>/gi, '<li>&nbsp;</li>') // Empty list items
    
    // Fix span and div issues
    .replace(/<span><\/span>/gi, '') // Remove empty spans
    .replace(/<div><\/div>/gi, '') // Remove empty divs
    .replace(/<strong><\/strong>/gi, '') // Remove empty strong tags
    .replace(/<em><\/em>/gi, '') // Remove empty em tags
    
    // Fix attribute quote issues
    .replace(/(\w+)=([^"\s>]+)(\s|>)/g, '$1="$2"$3') // Add quotes to unquoted attributes
    
    // Fix malformed self-closing tags specifically
    .replace(/<(\w+)([^>]*?)\/>/gi, (match, tagName, attrs) => {
      // List of tags that should be self-closing in XHTML
      const selfClosingTags = ['br', 'hr', 'img', 'input', 'meta', 'link', 'area', 'base', 'col', 'embed', 'source', 'track', 'wbr'];
      if (selfClosingTags.includes(tagName.toLowerCase())) {
        return `<${tagName}${attrs}/>`;
      } else {
        // For non-self-closing tags, convert to open/close pair
        return `<${tagName}${attrs}></${tagName}>`;
      }
    })
    
    // Final validation: ensure proper XML structure
    .replace(/&(?![a-zA-Z]+;|#\d+;|#x[0-9a-fA-F]+;)/g, '&amp;') // Escape unescaped ampersands
    .replace(/</g, '&lt;').replace(/>/g, '&gt;') // Temporarily escape all tags
    .replace(/&lt;([^&]+?)&gt;/g, '<$1>') // Restore valid tags
    .replace(/&lt;\s*\/\s*([^&]+?)\s*&gt;/g, '</$1>') // Restore closing tags
    
    // Clean up any double-escaped content
    .replace(/&amp;amp;/g, '&amp;')
    .replace(/&amp;lt;/g, '&lt;')
    .replace(/&amp;gt;/g, '&gt;')
    .replace(/&amp;quot;/g, '&quot;')
    .replace(/&amp;apos;/g, '&apos;');
}

/**
 * ADVANCED HTML/XHTML SANITIZATION AND VALIDATION
 * S·ª≠ d·ª•ng htmlparser2 + he ƒë·ªÉ ƒë·∫£m b·∫£o HTML/XHTML ho√†n to√†n h·ª£p l·ªá cho Confluence
 */
function advancedHTMLSanitization(content: string): string {
  console.log('üî¨ Starting advanced HTML sanitization with htmlparser2...');
  
  try {
    // Step 1: Preprocess content to fix obvious issues
    let processedContent = content
      // Fix unclosed self-closing tags first
      .replace(/<(br|hr|img|input|meta|link|area|base|col|embed|source|track|wbr)([^>]*?)(?<!\/)\s*>/gi, '<$1$2/>')
      // Ensure proper quotes around attributes
      .replace(/(\w+)=([^"\s>]+)(\s|>)/g, '$1="$2"$3')
      // Fix common encoding issues before processing
      .replace(/&(?![a-zA-Z0-9#]+;)/g, '&amp;')
      // Remove any null bytes or control characters
      .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '')
      // Fix common Vietnamese encoding issues
      .replace(/√¢‚Ç¨‚Ñ¢/g, "'").replace(/√¢‚Ç¨≈ì/g, '"').replace(/√¢‚Ç¨/g, '"');

    // Step 2: Parse with htmlparser2 to validate and reconstruct safely
    let finalHTML = '';
    let tagStack: string[] = [];
    let hasErrors = false;
    
    // Confluence allowed tags
    const allowedTags = new Set([
      'p', 'br', 'div', 'span', 'strong', 'em', 'b', 'i', 'u', 's', 'sub', 'sup',
      'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
      'ul', 'ol', 'li',
      'table', 'thead', 'tbody', 'tfoot', 'tr', 'td', 'th',
      'a', 'img',
      'blockquote', 'pre', 'code',
      'hr',
      // Confluence specific macros
      'ac:structured-macro', 'ac:parameter', 'ac:rich-text-body', 'ac:plain-text-body'
    ]);

    // Self-closing tags for XHTML compliance
    const selfClosingTags = new Set(['br', 'hr', 'img', 'input', 'meta', 'link', 'area', 'base', 'col', 'embed', 'source', 'track', 'wbr']);
    
    const parser = new htmlparser2.Parser({
      onopentag(tagname, attributes) {
        // Only allow whitelisted tags
        if (!allowedTags.has(tagname.toLowerCase())) {
          console.warn(`‚ö†Ô∏è Skipping disallowed tag: ${tagname}`);
          return;
        }

        // Reconstruct opening tag with proper formatting
        let attrString = '';
        for (const [key, value] of Object.entries(attributes)) {
          // Sanitize and escape attribute values
          if (value != null) {
            const escapedValue = he.encode(String(value), { 
              useNamedReferences: false,
              allowUnsafeSymbols: false 
            });
            attrString += ` ${key}="${escapedValue}"`;
          }
        }
        
        // Check if it's a self-closing tag for XHTML
        if (selfClosingTags.has(tagname.toLowerCase())) {
          finalHTML += `<${tagname}${attrString}/>`;
        } else {
          finalHTML += `<${tagname}${attrString}>`;
          tagStack.push(tagname);
        }
      },
      
      onclosetag(tagname) {
        // Only process whitelisted tags
        if (!allowedTags.has(tagname.toLowerCase())) {
          return;
        }

        // Only add closing tag if it's not self-closing and was opened
        if (!selfClosingTags.has(tagname.toLowerCase())) {
          // Check if this tag was actually opened
          const lastOpenTag = tagStack.pop();
          if (lastOpenTag === tagname) {
            finalHTML += `</${tagname}>`;
          } else {
            // Tag mismatch - try to recover
            console.warn(`‚ö†Ô∏è Tag mismatch: expected ${lastOpenTag}, got ${tagname}`);
            hasErrors = true;
            if (lastOpenTag) {
              // Close the last opened tag first
              finalHTML += `</${lastOpenTag}>`;
            }
            // If this tag is still open in the stack, close up to it
            const tagIndex = tagStack.lastIndexOf(tagname);
            if (tagIndex >= 0) {
              // Close all tags after this one
              for (let i = tagStack.length - 1; i > tagIndex; i--) {
                finalHTML += `</${tagStack[i]}>`;
              }
              // Close this tag
              finalHTML += `</${tagname}>`;
              // Remove all closed tags from stack
              tagStack.splice(tagIndex);
            }
          }
        }
      },
      
      ontext(text) {
        // Properly escape text content but preserve already escaped entities
        const escapedText = he.encode(text, { 
          useNamedReferences: false,
          allowUnsafeSymbols: false 
        });
        // Preserve existing valid entities
        finalHTML += escapedText.replace(/&amp;(#\d+|#x[0-9a-fA-F]+|[a-zA-Z]+);/g, '&$1;');
      },
      
      oncomment(data) {
        // Keep comments but sanitize them
        const sanitizedComment = he.encode(data, { useNamedReferences: false });
        finalHTML += `<!--${sanitizedComment}-->`;
      },

      onerror(error) {
        console.error('‚ö†Ô∏è HTML parsing error:', error);
        hasErrors = true;
      }
    }, {
      decodeEntities: true,
      lowerCaseAttributeNames: false,  // Keep case for Confluence attributes like ac:name
      recognizeSelfClosing: true
    });

    // Step 3: Parse the content
    parser.write(processedContent);
    parser.end();

    // Step 4: Close any remaining unclosed tags
    while (tagStack.length > 0) {
      const unclosedTag = tagStack.pop();
      console.warn(`‚ö†Ô∏è Auto-closing unclosed tag: ${unclosedTag}`);
      finalHTML += `</${unclosedTag}>`;
      hasErrors = true;
    }

    // Step 5: Final cleanup and validation
    const result = finalHTML
      // Remove empty tags that could cause issues
      .replace(/<(\w+)([^>]*?)>\s*<\/\1>/g, '') // Remove empty tags like <p></p>
      .replace(/<p>\s*<\/p>/gi, '') // Remove empty paragraphs specifically
      .replace(/>\s+</g, '><') // Remove spaces between tags
      .replace(/\s+/g, ' ') // Normalize whitespace
      .trim();

    console.log('‚úÖ Advanced HTML sanitization complete');
    console.log(`üìä Original length: ${content.length}, Final length: ${result.length}`);
    if (hasErrors) {
      console.warn('‚ö†Ô∏è Some HTML errors were detected and fixed during processing');
    }
    
    return result;

  } catch (error) {
    console.error('‚ùå Error in advanced HTML sanitization:', error);
    console.log('üîÑ Falling back to basic validation...');
    // Fallback to existing validation
    return validateXHTMLForConfluence(content);
  }
}
